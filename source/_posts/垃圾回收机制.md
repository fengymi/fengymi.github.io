---
title: 垃圾回收机制
date: 2018-02-27 15:19:56
toc: true
tags: [java,jvm,垃圾回收器,gc]
---

### 垃圾对象判定算法
Java中根据不同的垃圾对象判定算法，判断哪些Java对象是不是垃圾。

#### 引用计数算法
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器都为0的对象就是不可能再被使用的。
优点：<b>实现简单</b>,<b>效率高</b>
缺点：<b>很难解决对象之间的相互循环引用</b>（所以一般jvm实现不用该算法）

#### 根搜索法(GC Roots Tracing)
Java主要是采用根搜索算法来判定对象是否存活的。这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。在Java语言里，可作为GC Roots的兑现包括下面几种：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中的类静态属性引用的对象。
* 方法区中的常量引用的对象。
* 本地方法栈中JNI（Native方法）的引用对象。

实际上，在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。如果该对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize()方法。finalize()方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize()方法<b>最多只会被系统自动调用一次</b>），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize()方法中成功拯救自己，只要在finalize（）方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。

### 垃圾收集算法
根据垃圾对象判断算法之后，得到了垃圾对象，就需要对这些垃圾进行回收了。看看常用的垃圾回收算法之间的区别：

#### 标记-清除算法 (Mark-Sweep)
标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。
![清除标记算法](/img/java/jvm/清除标记算法.png)
优点：
* 实现简单
缺点：
* 存在大量的空间碎片,无法分配大对象。
* 标记和清除过程的效率都不高（对象不存在连续分配的内存空间中）。
#### 复制算法 (Copying)
将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。
![复制算法](/img/java/jvm/复制算法.png)
优点：
* 每次只对一块内存进行回收，运行高效。
* 只需移动栈顶指针，按顺序分配内存即可，实现简单。
* 内存回收时不用考虑内存碎片的出现。
缺点：
* 可一次性分配的最大内存缩小了一半

Java 的新生代串行垃圾回收器中使用了复制算法的思想
![堆内存模型](/img/java/jvm/堆内存模型.png)
 <b>堆大小</b> = <b>新生代</b> + <b>老年代</b>。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定大小，–XX:NewRatio指定比例默认1:2
 <b>新生代</b> = <b>Eden</b> + (<b>From Survivor</b> + <b>To Survivor</b>);两块Survivor大小相同、地位相等，且可进行角色互换的空间块, –XX:SurvivorRatio修改比例 默认8:1:1。JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。
 <b>执行过程:</b> 当触发垃圾回收时，将Eden中的对象复制到空闲Survivor中(ex:To),如果是<b>大对象</b>直接进入老年代，<b>当空闲Survivor已满</b>也会直接进入<b>老年代</b>,使用中的Survivor(ex:From)也按改条件进入空闲Survivor
 

